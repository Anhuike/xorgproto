The X Input Extension
=====================

                                Version 2.0
                                Version 2.1

                              Peter Hutterer
                         peter.hutterer@redhat.com
                               Red Hat, Inc.

                               Daniel Stone
                           daniel@fooishbar.org
                              Collabora, Ltd.

                              Chase Douglas
                        chase.douglas@canonical.com
                              Canonical, Ltd.



1. Introduction
---------------

The X Input Extension version 2.0 (XI2) is the second major release of the X
Input Extension.

XI2 provides a number of enhancements over version 1.5, including:

- use of XGE and GenericEvents. GenericEvents are of flexible length with a
  minimum length of 32 bytes.
- explicit device hierarchy of master and slave devices. See Section 4.
- use of multiple independent master devices (Multi-Poiner X or MPX).
- the ability for devices to change capabilities at runtime.
- raw device events

XI2's intent is to replace both core input processing and prior versions of
the X Input Extension. Historically, the majority of applications employed the
core protocol requests and events to handle user input. The core protocol does
not provide information about which device generated the event. The X Input
Extension version up to 1.5 requires the differentiation between core and
extended devices. Extended devices may not be core devices and thus cannot be
used on applications employing the core protocol. XI2 addresses both of these
issues by enabling devices to be both extended and core devices and providing
device information in each event (with the exception of core events).

1.1 X Input Extension version 2.1 (XI 2.1)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
XI 2.1 introduces support for multi-touch devices. The traditional
pointer/keyboard approach enforced by XI 2.0 with the master/slave device
hierarchy is not always suitable for multi-touch devices that can provide a
dynamic number of multiple independent input points per physical device.
Furthermore, as such devices are often direct input devices (e.g. touchscreens,
able to focus without a pointer), the virtual abstraction of master devices is
not always necessary.

The additions in XI 2.1 aim to:

- support a dynamic number of simultaneous touch points,
- support devices that are both multi-touch and traditional pointer devices,
- while supporting pre-XI2.1 clients through emulation of XInput and core
  pointer events.

XI 2.1 caters for two modes of touch input devices:

- direct multi-touch input devices such as touch screens. These devices
  provide independent touchpoints that can occur anywhere on the screen and
  are usually the result of direct touch interaction.
- indirect touch input devices such as multi-touch trackpads. These devices
  provide independent touchpoints that may need to be interpreted
  relative to the current position of the pointer on that same device. Such
  interactions are usually the result of a gesture performed on the device.

A device may change its touch mode at runtime. Clients are informed which
type of touch device they are dealing with. See XIQueryDevice for more
information.

Touch device support is only available to clients supporting version 2.1 or
later of the X Input Extension. Clients must use the XIQueryVersion request to
announce support of this version.

XI 2.1 requires devices to track touch points over time. Devices that cannot
do so in hardware must employ software trackers to be usable with XI 2.1.

//                            ❧❧❧❧❧❧❧❧❧❧❧

2. Notations used in this document
----------------------------------

Notation for requests:

    ┌───
        Name of request
            name of request field:       type of request field
            name of request field:       type of request field
            ▶
            name of reply field:         type of reply field
    └───

Notation for events:

    ┌───
        Name of event
            name of field:               type of field
            name of field:               type of field
    └───

Complex fields are specified in the following notation:

          name of field:                  COMPLEXFIELDTYPE

or, if multiple of these fields exist:

          name of field:                  LISTofCOMPLEXFIELDTYPE

    COMPLEXFIELDTYPE:  { name of subfield:   type of subfield,
                         name of subfield:   type of subfield }

//                            ❧❧❧❧❧❧❧❧❧❧❧

3. Interoperability between version 1.x and 2.0
-----------------------------------------------

There is little interaction between 1.x and 2.x versions of the X Input
Extension. Clients are requested to avoid mixing XI1.x and XI2 code as much as
possible. Several direct incompatibilities are observable:

3.1 Limitations resulting from different variable ranges
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

XI2 provides a larger range for some fields than XI1. As a result, XI1 clients
may not receive data an XI2 client receives.
These fields include:

- devices with a deviceid of greater than 127 are invisible to XI1 clients.
- key events and key grabs featuring larger than 255 can only be sent to XI2
  clients.
- no subpixel information is avialable to XI1 clients. If motion events are in
  a subpixel range only, the server may omit these events and an XI 1.x client
  will not receive events until the pixel boundary is crossed.


3.2 Blocking of grabs
~~~~~~~~~~~~~~~~~~~~~

XI1 grabs are different to XI2 grab and a device may not be grabbed through an
XI2 grab if an XI1 grab is currently active on this device or vice versa.
Likewise, a keycode or button already grabbed by an XI 1.x or XI2 client may
not be grabbed with the same modifier combination by an XI2 or XI 1.x client,
respectively.

3.3 Invisibility of Master Devices
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

XI 1.x was not designed with support for multiple master devices (see Section
4). As a result, only the first master pointer and master keyboard are visible
to XI 1.x clients, all other master devices are invisible and cannot be
accessed from XI 1.x calls.

//                            ❧❧❧❧❧❧❧❧❧❧❧

4. The Master/Slave device hierarchy
------------------------------------

XI2 introduces a device hierarchy split up into so-called Master Devices (MD)
and Slave Devices (SD).

4.1 Master devices
~~~~~~~~~~~~~~~~~~
An MD is a virtual device created and managed by the server. MDs may send core
events and XI events. However, an MD does not represent a physical device and
relies on SDs for event generation. MDs come in two forms: as master pointers
or as master keyboards. A master pointer is represented by a visible cursor on
the screen. A master keyboard is represented by a keyboard focus.

Each master pointer is paired with the respective master keyboard and vice
versa, and this pairing is constant for the lifetime of both input devices.
Clients can use this pairing behaviour to implement input paradigms that
require pointer and keyboard interation (e.g. SHIFT + Click).

4.2 Slave devices
~~~~~~~~~~~~~~~~~
An SD is usually a physical device configured in the server. SDs are not
represented by a cursor or keyboard focus and may be attached to a master
pointer or master keyboard. SDs can only be attached to any master of the same
type (e.g. a physical pointer device can be attached to any master pointer).

If an event is generated by an SD

- if the SD is attached to a master pointer, it changes the position and/or
  button state of the master pointer.
- if the SD is attached to a master keyboard, it sends events to this
  keyboard's focus window (if applicable) and/or changes the modifier state of
  this keyboard.
- if the SD is not attached to an MD ("floating"), it does not change
  any master device. The SD has its own (invisible) sprite and its own focus.
  Both the sprite and the focus must be managed explicitly by the client
  program.

4.3 Event processing for attached slave devices
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Whenever an SD changes its logical state,

- the event is delivered as an XI event to any interested clients. If the
  device is floating, event processing stops.
  Otherwise, if the device is attached,
- the master device changes its classes to reflect the SD's capabilities. All
  interested clients are notified of this device change.
- then, the event is delivered as an XI event from the MD to any interested
  clients. If the event has been delivered, event processing stops.
  Otherwise,
- the event is delivered as a core event to any interested clients.

Given that W is the event window, and P the parent window of W, event delivery
to P is only attempted if neither the XI event, nor the core event has been
delivered on W. Once an event has been delivered as either XI or core event,
event processing stops.

4.4. The ClientPointer principle
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Many core protocol and some extension requests are ambiguous when multiple
master devices are available (e.g. QueryPointer does not specfy which pointer).
The X server does not have the knowledge to chose the contextually correct
master device. For each client, one master pointer is designated as this
clients's "ClientPointer". Whenever a client sends an ambiguous request (e.g.
QueryPointer), the ClientPointer or the keyboard paired with the ClientPointer
is chosen to provide the data for this request.

This ClientPointer may be explicitly assigned to a client with the
SetClientPointer call. If no ClientPointer is set when a client issues an
ambiguous request, the server choses one device as the ClientPointer. The
method of chosing a ClientPointer from the available master pointers is
implementation-specific.

If the master pointer currently set as ClientPointer for one or more clients is
removed, the server may either unset the ClientPointer setting or change the
ClientPointer to a different master pointer.

5 Touch device support
----------------------

Touch event processing differs from normal event processing in a few ways,
most notably in that touch events are processed partially out-of-band from
pointer and keyboard events (see section 4.4.5) and in that
touch events may be sent to multiple clients simultaneously (see sections
4.4.2 and 4.4.3).

4.4.1 Touch event sequences
^^^^^^^^^^^^^^^^^^^^^^^^^^^

Touch input follows a three-stage cycle: 

        begin - update - update - ... - end

i.e. “begin” the sequence by touching the device, “update” the current
touch location or properties any number of times, and finally “end” the
sequence by ceasing to touch the device.  Within this document, the term
"touch sequence" is used to describe the above chain of events.
In the protocol, the three stages are represented with the event
types TouchBegin, TouchUpdate, and TouchEnd, respectively.
A touch sequence always generates TouchBeing and TouchEnd events. It may
generate TouchUpdate events.

A client must select for TouchBegin, TouchUpdate, and TouchEnd events. A
TouchBegin event is sent to the client with the position information and
properties of the touch when it began on the touch device.
Note that the logical state of a device (as seen by means of the
protocol) may lag the physical state if device event processing is
affected by grabs. The event timestamp of touch events always represents the
time the event occurred.

A TouchUpdate event is sent to the client whenever the position or any other
property of the touch changes. Note that the server may compress multiple
TouchUpdate events into one. If compression occurs, the TouchUpdate event
represents the last state of the touch.

A TouchEnd event is sent to the client when the touch ceases.

4.4.2 Ownership of touch events
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Touch sequences may send events to multiple clients in parallel. At any given
time, only one client is in control of the touch sequence and is referred to as
the "owner" of the sequence.

Clients may want to receive events only after they become the owner of a touch
sequence. This prevents unnecessary process wakeups and provides for simpler
handling of a stream of touch events. Such clients must select for touch begin,
update, and end events. When the client becomes the owner of a touch sequence,
a touch begin event will be sent. This event will represent the position and
properties of the touch when it began on the touch device. The server may buffer
copies of multiple touch update events while the touch sequence was owned by
another client. After sending the touch begin event, any buffered touch update
events will be sent. If the touch position or properties have changed since the
touch began, at least one touch update or touch end event will be sent to denote
the new position and properties. There is no guarantee that any more than one
touch update or touch end event will be buffered. The event timestamp of the
buffered events represent the time the event occurred.

Other clients may want access to the stream of touch events from a touch
sequence before they become the owner of the sequence. Clients must use caution
when handling these events; any action taken must be undone if the touch
sequence ends without the client becoming the owner. Such clients must select
for touch begin, update, end, and ownership events. A touch begin event is sent
to all such clients when a touch sequence has initiated. When touch position or
properties are changed, the client will be sent touch update events. Once the
client, including the initial owner, becomes the owner of the touch sequence, a
touch ownership event will be sent. When the touch ends, the owner will receive
a touch end event if it is a touch grabbing client and has accepted the touch
sequence as outlined below or if it is receiving touch events through a
selection. Otherwise, the owner will receive a touch update event with the
pending end flag set. All other clients will receive a touch update event with
the pending end flag set.

Touch grabs are similar to standard input event grabs in that they take
precedence over selections and are searched from the root window to the child
window. When a touch grab is activated, the client will receive a touch
ownership event. The owner must either “accept” or "reject" the touch sequence,
though it may do so at any time, including after the touch sequence has ended.
If the owner accepts the touch sequence, touch end events will be sent to all
other clients listening to events from the touch sequence. If the owner rejects
the touch sequence, a touch end event will be sent to the owner and further
grabs will be checked for the touch sequence. If any touch client becomes the
owner of the touch sequence, it will be sent a touch ownership event. Touch
grabbing clients must register for touch ownership events through the grab and
be able to handle events while they are not the owner of the touch sequence.

A touch sequence is only considered to be meaningful in its entirety: clients
may not capture part of a touch sequence, interpret only that part, and then
pass ownership of the touch sequence on to another client. A special exception
to this rule is made for clients who passively grab a touch with grab type
TouchObserve, or for when a client rejects a touch with mode TouchObserve. Such
clients are passed over for touch ownership, but will continue to receive touch
update events for the touch sequence.

A TouchEnd event will always be sent to a client when it will receive no more
events from a particular touch, regardless of why (grab or selection removed,
owner accepted, the client having rejected the touch, etc).

Only one client may select, and only one client may grab, touch events for a
physical device on a window. As an example, selecting for AllDevices will
prevent any other client from selecting for touch events for any device on the
same window. When a slave device is attached to a master device, any selections
on any windows for touch events for the slave device ID will be canceled.
Clients selecting for individual slave devices are suggested to select for
HierarchyChanged events to be notified when this occurs.

4.4.2 Touch device modes
^^^^^^^^^^^^^^^^^^^^^^^^

Touch devices come in many different forms with varying capabilities. The
following device modes are defined for this protocol:

DirectTouch:
    These devices map their input region to a subset of the screen region. Touch
    focus is determined according to where the touch occurs in the mapped screen
    region. An example of a DirectTouch device is a touchscreen.

DependentTouch:
    These devices do not have a direct correlation between a touch location and
    a position on the screen. Touch events are delivered according to the
    location of the device's cursor. An Example of a DependentTouch device is a
    trackpad.

IndependentPointer:
    These devices do not have any correlation between touch events and pointer
    events. Pointer events are generated by physical interactions with the
    device that are independent of any touch events. An example of an
    IndependentPointer device is a mouse with a touch surface used for scrolling
    or other gestural input.

SemiMultitouch:
    These devices only report the number of touches and the bounding box of the
    touches on the touch surface. The touch information is sent as one touch
    event sequence with four touch valuators defining the bounding box. Touch
    events are delivered according to the location of the device's cursor.
    Although DirectTouch and IndependentPointer devices may also be
    SemiMultitouch devices, such devices are not allowed through this protocol.

A device is identified as only one of the device modes above at any time. For
the purposes of this protocol document, indirect touch devices refers to
DependentTouch, IndependentPointer, and SemiMultitouch devices.

4.4.3 Touch event delivery
^^^^^^^^^^^^^^^^^^^^^^^^^^

Window sets for event propagation for direct device touches contain the windows
from the root to the child in which the touch originated.

Indirect device window sets depend on whether other touches are active. For
the first touch on an indirect device, the window set contains the windows from
the root to the current window underneath the position of the device's pointer.
For subsequent touches on the device, the window set is identical to the window
set of the first touch. Once all touches have been released, the window set is
reset and re-calculated on the first subsequent touch.

The delivery of touch events is not changed by any modifications to the window
hierarchy after the window set has been determined for the touch, nor is it
affected by new grabs or selections.

No touches from an indirect device may begin while the device is floating, as
it does not have an associated pointer position to focus events.

4.4.4 Pointer event handling for indirect touch devices
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Indirect touch devices are expected to generate pointer events. In contrast with
direct touch devices, as stated below, the server will not generate pointer
events on behalf of indirect touch devices. Further, pointer events from
indirect touch devices are delivered independently of touch events.

DependentTouch and SemiMultitouch devices may generate pointer events by mapping
one touch sequence to the pointer. In these cases, events for both the pointer
and its associated touch sequence will have the PointerEmulated flag set.

When the cursor of an attached master pointer of an indirect device leaves the
window of a touch grab or selection, or when a client activates a pointer grab
on either the master or slave device, touch begin and touch update events will
be withheld. When the pointer re-enters the window or the pointer grab is
deactivated, touch update events will be sent with updates to any touch
positions and properties since the last touch event sent. Touch begin events for
any new touches will also be sent, along with touch update events for new
touches that have changed position or properties since the touch began. No events
will be delivered for touches that began and ended while touch events were
withheld.

4.4.5 Pointer emulation for direct touch devices
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

In order to facilitate backwards compatibility with legacy clients, direct touch
devices will emulate pointer events. Pointer emulation events will only be
delivered through the attached master device; no pointer events will be emulated
for floating touch devices. Further, only one touch from any attached slave
direct touch device may be emulated per master device at any time.

Pointer events are emulated as follows:

* Touch begin events generate a pointer motion event to the location of the
  touch, followed by a button press event for button 1.
* Touch update events generate a pointer motion event to update the location
  of the touch.
* Touch end events generate a pointer motion event to the location of the touch
  if the touch has moved, followed by a button release event for button 1.

A touch sequence may only be owned by one client at a time. When pointer events
are emulated from a touch sequence and delivered through a pointer grab, the
grabbing client implicitly becomes the owner of the touch sequence.

A pointer grabbing client is considered to have accepted ownership of the touch
sequence when the following occurs:

* The emulated button press event is delivered through an asynchronous grab.
* The emulated button press event is delivered through a synchronous grab and
  further events are allowed through to the grabbing client.
* The emulated button press event is delivered through a synchronous grab and
  then the grab is deactivated without replaying the button press event.

Touch and pointer grabs are mutually exclusive. For a given window, any touch
grab is activated first. If there is no touch grab or the touch grab is
rejected, any pointer grab is activated. If there is a pointer grab and the
grabbing client accepts ownership of the touch sequence as outlined above, the
touch sequence is ended for all other clients listening for touch events.
Otherwise, if there is no pointer grab or the grabbing client replays the
pointer events without accepting the touch sequence, the next window in the
window set is checked for grabs.

If the touch sequence is not accepted by any client through a grab, the touch
and emulated pointer events may be delivered to a client selecting for them.
Event propagation for the touch sequence ends at the first client selecting for
touch or pointer events. If a window has both touch and pointer event
selections, only the touch events will be delivered.

Both the emulated pointer events and their associated touch events will have the
PointerEmulated flag set.

4.5. The ClientPointer principle
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Many core protocol and some extension requests are ambiguous when multiple
master devices are available (e.g. QueryPointer does not specfy which pointer).
The X server does not have the knowledge to chose the contextually correct
master device. For each client, one master pointer is designated as this
clients's "ClientPointer". Whenever a client sends an ambiguous request (e.g.
QueryPointer), the ClientPointer or the keyboard paired with the ClientPointer
is chosen to provide the data for this request.

This ClientPointer may be explicitly assigned to a client with the
SetClientPointer call. If no ClientPointer is set when a client issues an
ambiguous request, the server choses one device as the ClientPointer. The
method of chosing a ClientPointer from the available master pointers is
implementation-specific.

If the master pointer currently set as ClientPointer for one or more clients is
removed, the server may either unset the ClientPointer setting or change the
ClientPointer to a different master pointer.

//                            ❧❧❧❧❧❧❧❧❧❧❧

5. Data types
-------------

    BUTTONMASK
            A binary mask defined as (1 << button number).
            A SETofBUTTONMASK is a binary OR of zero or more BUTTONMASK.

    DEVICE { DEVICEID, AllDevices, AllMasterDevices }
            A DEVICE specifies either a DEVICEID or AllDevices or
            AllMasterDevices.

    DEVICEID { CARD16 }
            A DEVICEID is a numerical ID for a device currently available in the
            server. The server may re-use a device ID after a device's removal.
            The device IDs 0 and 1 are reserved.
            AllDevices ........ 0
            AllMasterDevices .. 1

    DEVICEUSE { MasterPointer, MasterKeyboard, SlavePointer,
                SlaveKeyboard, FloatingSlave }
            A DEVICEUSE field specifies the current use of a device in the MD/SD
            device hierarchy. See Section 4 for more information.

    EVENTMASK
            An EVENTMASK is a binary mask defined as (1 << event type).
            A SETofEVENTMASK is a binary OR of zero or more EVENTMASK.

    FP1616
            Fixed point decimal in 16.16 format as one INT16 and one CARD16.
            The INT16 contains the integral part, the CARD32 the decimal fraction
            shifted by 16.

    FP3232
            Fixed point decimal in 32.32 format as one INT32 and one CARD32.
            The INT32 contains the integral part, the CARD32 the decimal fraction
            shifted by 32.

    VALUATORMASK
            A binary mask defined as (1 << valuator number).
            A SETofVALUATORMASK is a binary OR of zero or more VALUATORMASK.

//                            ❧❧❧❧❧❧❧❧❧❧❧

6. Errors
---------

Errors are sent using core X error reports.

    Device
            A value for a DEVICE argument does not specify a valid DEVICE.

//                            ❧❧❧❧❧❧❧❧❧❧❧

7. Requests:
------------

The server does not guarantee that the length of a reply remains constant in
future revisions of XI2. A client must always retrieve the exact length of the
protocol reply from the connection, even if the reply is longer than defined
for the XI2 version supported by the client.
Additional bytes in a request may include data supported in later versions of
XI2. Clients should ignore this data. Padding bytes in XI2 protocol requests
are required to be 0.

7.1 Requests introduced in version 2.0
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    ┌───
        XIQueryVersion
        major_version:          CARD16
        minor_version:          CARD16
        ▶
        major_version:          CARD16
        minor_version:          CARD16
    └───

The client sends the highest supported version to the server and the
server sends the highest version it supports, but no higher than the
requested version. Major versions changes can introduce incompatibilities
in existing functionality, minor version changes introduce only backward
compatible changes.  It is the client's responsibility to ensure that the
server supports a version which is compatible with its expectations.

    major_version
        Major XI2 version.
    minor_version
        Minor XI2 version.

If major_version is less than 2, a BadValue error occurs.

    ┌───
        XIQueryDevice
        DEVICE                  deviceid
        ▶
        num_devices:            CARD16
        deviceinfo:             LISTofDEVICEINFO
    └───

    DEVICEINFO { deviceid:              DEVICEID
                 use:                   DEVICEUSE
                 attachment:            DEVICEID
                 enabled:               BOOL
                 num_classes:           CARD16
                 name_len:              CARD16
                 name:                  LISTofCHAR8
                 classes:               LISTofCLASS }

    CLASS { BUTTONCLASS, KEYCLASS, AXISCLASS, TOUCHCLASS*, TOUCHAXISCLASS* }

    BUTTONCLASS { type:                 ButtonClass
                  length:               CARD16
                  sourceid:             CARD16
                  buttons_len:          CARD16
                  state:                SETofBUTTONMASK
                  labels:               LISTofATOM }

    KEYCLASS    { type:                 KeyClass
                  length:               CARD16
                  sourceid:             CARD16
                  num_keys:             CARD16
                  keys:                 LISTofCARD32 }

    AXISCLASS   { type:                 AxisClass
                  length:               CARD16
                  sourceid:             CARD16
                  axisnumber:           CARD16
                  label:                ATOM
                  min:                  FP3232
                  max:                  FP3232
                  value:                FP3232
                  resolution:           CARD32 }

    TOUCHCLASS* { type:                 TouchClass
                  length:               CARD16
                  sourceid:             CARD16
                  mode:                 TOUCHMODE
                  num_touches:          CARD16 }

    TOUCHAXISCLASS* {
                  type:                 TouchAxisClass
                  length:               CARD16
                  sourceid:             CARD16
                  axisnumber:           CARD16
                  label:                ATOM
                  min:                  FP3232
                  max:                  FP3232
                  resolution:           CARD32 }

    TOUCHMODE* { DirectTouch, DependentTouch, IndependentPointer,
                 SemiMultitouch }

* since XI 2.1

XIQueryDevice details information about the requested input devices.

    devices
        The device to list. If devices is AllDevices, all enabled and
        disabled devices are listed. If devices is AllMasterDevices, all
        enabled and disabled master devices are listed. If devices is a
        valid DEVICE, only this DEVICE is listed and num_devices is 1.
    num_devices
        The number of deviceinfos returned.

Each deviceinfo is detailed as follows:

    deviceid
        The unique ID of the device. Device IDs may get re-used when a device
        is removed.
    use
        If the device is a master pointer, use is MasterPointer.
        If the device is a master keyboard, use is MasterKeyboard.
        If the device is a slave pointer, use is SlavePointer.
        If the device is a slave keyboard, use is SlaveKeyboard.
        If the device is a floating slave, use is FloatingSlave.
    attachment
        If the device is a master pointer or a master keyboard, attachment
        specifies the paired master keyboard, or the paired master pointer,
        respectively.  If the device is a non-floating slave device
        attachment specifies the master device this device is attached to.
        If the device is a floating slave, attachment is undefined.
    enabled
        Zero if the device is disabled, non-zero otherwise.
    num_classes
        Number of classes provided.
    name_len
        Length of the name in bytes not including padding.
    classes
        Details the available classes provided by the device in an undefined
        order.
    name
        The device's name. padded to a multiple of 4 bytes.

For all classes, type specifies the device class. Clients are required
to ignore unknown device classes. The length field specifies the length
of the class in 4 byte units.
The following classes may occur only once: ButtonClass, KeyClass

    ButtonClass:
    type
        Always ButtonClass.
    length
        Length in 4 byte units.
    sourceid
        The device this class originates from.
    num_buttons
        Number of buttons provided by the device.
    labels
        List of Atoms specifying the label for each button. An Atom of None
        specifies an unlabeled button. Buttons are listed in the device-native
        order regardless of the current button mapping.
    state
        The current button mask for this device after button mapping is
        applied. Each bit representing a button is 1 if this button is
        logically down, or 0 otherwise. State is a multiple of 4-byte units
        and always contains at least num_buttons bits.

    KeyClass:
    type
        Always KeyClass.
    length
        Length in 4 byte units.
    sourceid
        The device this class originates from.
    num_keys
        Number of keycodes provided by the device.
    keys
        List of keycodes provided.

    AxisClass:
    type
        Always AxisClass.
    length
        Length in 4 byte units.
    sourceid
        The device this class originates from.
    axisnumber
        Axis number of this axis. The axis number is in device-native
        order and potential axis mappings are ignored.
    label
        Atom specifying the axis name. An Atom of None specifies an unlabeled
        axis.
    min
        Minimum value.
    max
        Minimum value.
    resolution
        Resolution in counts/meter.
    mode
        Relative or Absolute.
    value
        Last published axis value (if mode is absolute).

An axis in Relative mode may specify min and max as a hint to the
client. If no min and max information is available, both must be 0.

    XI 2.1:

    TouchClass:
    type
        Always TouchClass.
    length
        Length in 4 byte units.
    sourceid
        The device this class originates from.
    mode
        The device type of the touch device.
    num_touches
        The maximum number of simultaneous touchpoints the device may send.
        If num_touches is 0, the number of supported touches is unknown or
        unlimited.

A device with a TouchClass must provide one or more TOUCHAXISCLASS
specifiers.

    TouchAxisClass:
    type
        Always TouchAxisClass.
    length
        Length in 4 byte units.
    sourceid
        The device this class originates from.
    axisnumber
        Axis number of this axis. The axis number is in device-native
        order and potential axis mappings are ignored.
    label
        Atom specifying the axis name. An Atom of None specifies an unlabeled
        axis.
    min
        Minimum value for this axis.
    max
        Maximum value for this axis.
    resolution
        Resolution in counts/meter.

Devices generating touch events must provide exactly one TouchClass and
two or more TouchAxisClasses. TouchAxisClasses and AxisClasses are not
interchangable. A TouchAxisClass may only be part of a touch event,
whereas an AxisClass may only be part of non-touch events.

    ┌───
        XISelectEvents
            window:         Window
            num_masks:      CARD16
            masks:          LISTofEVENTMASK

    └───

    EVENTMASK { deviceid:          DEVICE,
                mask_len:          CARD16,
                mask:              SETofEVENTMASK

    window
        The window to select the events on.
    num_masks
        Number of items in masks.
    deviceid
        Numerical deviceid, or AllDevices, or AllMasterDevices.
    mask_len
        Length of mask in 4 byte units.
    mask
        Event mask. An event mask for an event type T is defined as (1 << T).

XISelectEvents selects for XI2 events on window.

If num_masks is 0, a BadValue error occurs.

Each mask sets the (and overwrites a previous) event mask for the DEVICE
specified through deviceid. The device AllDevices or
AllMasterDevices is treated as a separate device by server. A client's
event mask is the union of AllDevices, AllMasterDevices and the
per-device event mask.
The removal of device from the server unsets the event masks for the
device. If an event mask is set for AllDevices or AllMasterDevices, the
event mask is not cleared on device removal and affects all future
devices.

If mask_len is 0, the event mask for the given device is cleared.

The mask for XIHierarchyEvents may only be selected for XIAllDevices.
Setting it for any other device results in a BadValue error.

A client selecting for any of XI_TouchBegin, XI_TouchUpdate, or XI_TouchEnd
must select for all three events at the same time, else BadValue will be
returned. A client selecting for XI_TouchOwnership must select for all three
of the other touch events. If the selection for these touch events overlaps
a current selection by another client (e.g. selecting for a specific device
when another client has a selection for XIAllDevices), a BadAccess error occurs.

    ┌───
        XIGetSelectedEvents
            window:         Window
            ▶
            num_masks:      CARD16
            masks:          LISTofEVENTMASK
    └───

    window
        The window to select the events on.
    num_masks
        Number of items in masks.
    masks
        Selected event masks by this client.

Masks are returned on a per-device basis, with masks for AllDevices and
AllMasterDevices returned separately. A client can calculate the
effective mask for a device with a bitwise OR of the AllDevices, the
AllMasterDevices and the device-specific mask.

If num_masks is 0, no events have been selected by this client on the
given window.

    ┌───
        XIQueryPointer
            window:         Window
            deviceid:       DEVICEID
            ▶
            root:           Window
            child:          Window
            root_x:         FP1616
            root_y:         FP1616
            win_x:          FP1616
            win_y:          FP1616
            same_screen:    BOOL
            mods:           MODIFIERINFO
            group:          GROUPINFO
            buttons_len:    CARD16
            buttons:        SETofBUTTONMASK
    └───

Query a master pointer device for its current position.

    root
        The root window the pointer is logically on.
    child
        The child window of window that contains the pointer or None.
    root_x
    root_y
        Pointer position relative to the root window's origin.
    win_x
    win_y
        Pointer position relative to window or 0 if same_screen is false.
    same_screen
        True if window is on the same screen as the pointer.
    mods
        XKB modifier state on the paired device.
    group
        XKB group state on the paired device.
    buttons_len
        The length of buttons in 4 byte units.
    buttons
        Button state.

If the device is not a master pointer device or not a floating slave
pointer, a BadDevice error results.

    ┌───
        XIWarpPointer
            src_win:         Window
            dst_win:         Window
            src_x:           FP1616
            src_y:           FP1616
            src_width:       INT16
            src_height:      INT16
            dst_x:           FP1616
            dst_y:           FP1616
            deviceid:        DEVICEID
    └───

WarpPointer moves the pointer of deviceid as if the user had moved
the pointer. WarpPointer can only be called for MasterPointer and
FloatingSlave devices.

    src_win
       If src_window is not None, the move only takes place if src_window
       contains the pointer and the pointer is contained in the specified
       rectangle of src_window.
    dst_win
       If dst_win is None, this request moves the pointer by offsets
       dst_x/dst_y relative to the current position of the pointer. If
        dst_window is a window, this request moves the pointer to
       dst_x/dst_y relative to dst_win's origin.
    src_x
    src_y
    src_width
    src_height
       Specifies the source window rectangle.
    dst_x
    dst_y
        The relative coordinates to move the pointer if dst_win is None, or
        the absolute coordinates if dst_win is a window.
    deviceid
        The device to warp.

This request cannot be used to move the pointer outside the confine-to
window of an active pointer grab. An attempt will only move the pointer as
far as the closest edge of the confine-to window.

This request will generate events just as if the user had instantaneously
moved the pointer.

    ┌───
        XIChangeCursor
            win:             Window
            cursor:          Cursor
            deviceid:        DEVICEID
    └───

Change a master pointer's cursor on the specified window.

    window
        The window.
    cursor
        The new cursor or None.
    deviceid
        The master pointer device.

Whenever device enters a window W, the cursor shape is selected in the
following order:

- if the current window has a device cursor C(d) defined for device,
  display this cursor C(d).
- otherwise, if the current window has a cursor C(w) defined in the core
  protocol's window attributes, display cursor C(w).
- repeat on parent window until a cursor has been found.

The device cursor for a given window is reset once the window is destroyed
or the device is removed, whichever comes earlier.

If deviceid does not specify a master pointer, a BadDevice error
is returned.

    ┌───
        XIChangeHierarchy
            num_changes:     CARD8
            changes:         LISTofHIERARCHYCHANGES
    └───

    HIERARCHYCHANGE { ADDMASTER, REMOVEMASTER, ATTACHSLAVE, DETACHSLAVE }

    HIERARCHYCHANGETYPE { AddMaster, RemoveMaster, AttachSlave, DetachSlave }

    CHANGEMODE { Float, Attach }

    ADDMASTER { type:        HIERARCHYCHANGETYPE
                length:      CARD16
                name_len:    CARD16
                send_core:   BOOL
                enable:      BOOL
                name:        LISTofCHAR8 }

    REMOVEMASTER { type:            HIERARCHYCHANGETYPE
                   length:          CARD16
                   deviceid:        DEVICEID
                   return_mode:     CHANGEMODE
                   return_pointer:  DEVICEID
                   return_keyboard: DEVICEID }

    ATTACHSLAVE   { type:        HIERARCHYCHANGETYPE
                    length:      CARD16
                    deviceid:    DEVICEID
                    master:      DEVICEID }

    DETACHSLAVE { type:       HIERARCHYCHANGETYPE
                  length:     CARD16
                  deviceid:   DEVICEID }

XIChangeHierarchy allows a client to modify the MD/SD device
hierarchy (see Section 4).

    num_changes
        The number of changes to apply to the current hierarchy.
    changes
        The list of changes.

The server processes the changes in the order received from the client and
applies each requested change immediately. If an error occurs, processing
stops at the current change and returns the number of successfully applied
changes in the error.

    ADDMASTER creates a pair of master devices.
    type
        Always AddMaster.
    length
        Length in 4 byte units.
    name_len
        Length of name in bytes.
    send_core
        True if the device should send core events.
    enable
        True if the device is to be enabled immediately.
    name
        The name for the new master devices. The master pointer's name is
        automatically appended with " pointer", the master keyboard's name is
        automatically appended with " keyboard".

    REMOVEMASTER removes an existing master device.
    type
        Always RemoveMaster.
    length
        Length in 4 byte units.
    deviceid
        The device to remove.
    return_mode
        Return mode for attached slave devices.
        If return_mode is Float, all slave devices are set to floating.
        If return_mode is Attach, slave pointers are attached to
        return_pointer and slave keyboards are attached to
        return_keyboard.
    return_pointer
    return_keyboard
        The master pointer and master keyboard to attach slave devices to, if
        return_mode is Attach. If return_mode is Float, return_pointer
        and return_keyboard are undefined.

Removing a master pointer removes the paired master keyboard and vice
versa.

    ATTACHSLAVE attaches a slave device to a given master device.
    type
        Always ChangeAttachment.
    length
        Length in 4 byte units.
    deviceid
        Deviceid of the slave device.
    master
        The new master device to attach this slave device to.

If any clients are selecting for touch events from the slave device, their
selection will be canceled.

    DETACHSLAVE detaches a slave device from its current master device.
    type
        Always ChangeAttachment.
    length
        Length in 4 byte units.
    deviceid
        Deviceid of the slave device.

    ┌───
        XISetClientPointer
            win:             Window
            deviceid:        DEVICEID
    └───

Set the ClientPointer for the client owning win to the given device.

    win
         Window or client ID.
    deviceid
         The master pointer or master keyboard that acts as ClientPointer.

Some protocol requests are ambiguous and the server has to choose a device
to provide data for a request or a reply. By default, the server will
choose a client's ClientPointer device to provide the data, unless the
client currently has a grab on another device. See section 4.4 for more
details.

If win is None, the ClientPointer for this client is set to the given
device. Otherwise, if win is a valid window, the ClientPointer for the
client owning this window is set to the given device. Otherwise, if win is
not a valid window but a client with the client mask equal to win exists,
this client's ClientPointer is set to the given device.

If deviceid does not specify a master pointer or master keyboard, a
BadDevice error is returned.

If window does not specify a valid window or client ID and is not None, a
BadWindow error is returned.

    ┌───
        XIGetClientPointer
            win:             Window
            ▶
            set:             BOOL
            deviceid:        DEVICEID
    └───

Query the ClientPointer for the client owning win.

    win
        The window or client ID.
    set
        True if the client has a ClientPointer set.
    deviceid
        The master pointer that acts as a ClientPointer if set is True.

No difference is made between a ClientPointer set explicitly through
XISetClientPointer and a ClientPointer implicitly assigned by the server
in response to an ambiguous request.

    ┌───
        XISetFocus
            focus:           Window
            deviceid:        DEVICEID
            time:            Time
    └───

Set the focus for the given device to the given window. Future key events
from this device are sent to this window.
This request generates FocusIn and FocusOut events.

    focus
        A viewable window or None.
    deviceid
        The device to modify the focus window for.
    time
        Specifies the time to change the focus or CurrentTime.

If focus is None, key events from this device are discarded until a new
focus window is set. If focus is a viewable window, key events from this
device are sent to this window. If the window becomes unviewable, the
window's first viewable ancestor automatically becomes the focus window
and FocusIn and FocusOut events are sent as if a client had changed the
focus window.
This is equivalent to RevertToParent in the core XSetInputFocus window.

This request has no effect if the specified time is earlier than the
current last-focus-change time or is later than the current X server time.
Otherwise, the last-focus-change time is set to the specified time.

    ┌───
        XIGetFocus
            deviceid:        DEVICEID
            ▶
            focus:           Window
    └───

Return the current focus window for the given device.

    ┌───
        XIGrabDevice
            deviceid:        DEVICEID
            grab_window:     Window
            owner_events:    BOOL
            grab_mode:       { Synchronous, Asynchronous }
            paired_device_mode: { Synchronous, Asynchronous }
            time:            TIMESTAMP or CurrentTime
            cursor:          Cursor
            mask_len:        CARD16
            masks:           SETofEVENTMASK
            ▶
            status:          Success, AlreadyGrabbed, Frozen, InvalidTime, NotViewable
    └───

This request actively grabs control of the specified input device. Further
input events from this device are reported only to the grabbing client.
This request overides any previous active grab by this client for this
device.  This request does not, however, affect the processing of XI 2.1
touch events.

    deviceid
        The device to grab.
    grab_window
        Events are reported relative to the grab window.
    owner_events
        Specifies whether event will be reported normally or relative to the
        grab window.
    grab_mode
        Specifies if this device will be frozen as a result of the grab.
    paired_device_mode
        Specifies if the master device paired with this device will be frozen
        as a result of the grab.
    time
        A valid server time or CurrentTime.
    cursor
        The cursor to display for the duration of the grab or None.
    mask_len
        Length of mask in 4 byte units.
    mask
        Event mask. An event mask for an event type T is defined as (1 << T).
    status
        Success or the reason why the grab could not be established.

The masks parameter specifies which events the client wishes to receive
while the device is grabbed.

If owner-events is False, input events generated from this device are
reported with respect to grab-window, and are only reported if selected by
being included in the event-list.  If owner-events is True, then if a
generated event would normally be reported to this client, it is reported
normally, otherwise the event is reported with respect to the grab-window,
and is only reported if selected by being included in the event-list. For
either value of owner-events, unreported events are discarded.

If grab-mode is Asynchronous, device event processing continues normally.
If the device is currently frozen by this client, then processing of
device events is resumed. If grab-mode is Synchronous, the state of the
grabbed device (as seen by means of the protocol) appears to freeze,
and no further device events are generated by the server until the
grabbing client issues a releasing XIAllowEvents request or until the
device grab is released. Actual device input events are not lost while the
device is frozen; they are simply queued for later processing.

If the device is a slave device, the paired-device-mode is ignored.
Otherwise, if this device is a master device and paired-device-mode is
Asynchronous, event processing is unaffected by activation of the grab. If
this device is a master device and paired-device-mode is Synchronous, the
state of the master device paired with this device (as seen by means of the
protocol) appears to freeze, and no further events are generated by the
server until the grabbing client issues a releasing XIAllowEvents request
or until the device grab is released. Actual events are not lost while the
devices are frozen; they are simply queued for later processing.

If the cursor is not None and the device is a master pointer device, the
cursor will be displayed until the device is ungrabbed.

This request fails and returns:

    AlreadyGrabbed: If the device is actively grabbed by some other client.
    NotViewable: If grab-window is not viewable.
    InvalidTime: If the specified time is earlier than the last-grab-time for
                 the specified device or later than the current X server time.
                 Otherwise, the last-grab-time for the specified device is set
                 to the specified time and CurrentTime is replaced by the
                 current X server time.
    Frozen: If the device is frozen by an active grab of another client.

To release a grab of a device, use XIUngrabDevice.

    ┌───
        XIUngrabDevice
            deviceid:        DEVICEID
            time:            TIMESTAMP or CurrentTime
    └───

This request releases the device if this client has it actively grabbed
(from either XIGrabDevice or  XIPassiveGrabDevice) and
releases any queued events. If any devices were frozen by the grab,
XIUngrabDevice thaws them.

    deviceid
        The device to grab.
    time
        A valid server time or CurrentTime.

The request has no effect if the specified time is earlier than the
last-device-grab time or is later than the current server time.
This request generates FocusIn and FocusOut events.
An XIUngrabDevice is performed automatically if the event window for an
active device grab becomes not viewable.

    ┌───
        XIAllowEvents:
            deviceid:        DEVICEID
            time:            TIMESTAMP or CurrentTime
            event_mode:      { AsyncDevice, SyncDevice,
                               AsyncPairedDevice, SyncPairedDevice,
                               ReplayDevice, AsyncPair, SyncPair }
    └───

The XIAllowEvents request releases some queued events if the client
has caused a device to freeze.

    deviceid
        The device to grab.
    time
        A valid server time or CurrentTime.
    event_mode
        Specifies whether a device is to be thawed and events are to be
        replayed.

The request has no effect if the specified time is earlier than the
last-grab time of the most recent active grab for the client, or if the
specified time is later than the current X server time.

The following describes the processing that occurs depending on what constant
you pass to the event-mode argument:

    AsyncDevice:
        If the specified device is frozen by the client, event processing for that
        device continues as usual. If the device is frozen multiple times  by the
        client on behalf of multiple separate grabs, AsyncDevice thaws for
        all.
        AsyncDevice has no effect if the specified device is not frozen by the
        client, but the device need not be grabbed by the client.
    SyncDevice:
        If the specified device is frozen and actively grabbed by the client,
        event processing for that device continues normally until the next
        event is reported to the client. At this time, the specified device
        again appears to freeze. However, if the reported event causes the
        grab to be released, the specified device does not freeze.
        SyncDevice has no effect if the specified device is not frozen by the
        client or is not grabbed by the client.
     ReplayDevice:
        If the specified device is actively grabbed by the client and is frozen
        as the result of an event having been sent to the client (either from
        the activation of a XIGrabButton or from a previous XIAllowEvents with
        mode SyncDevice, but not from a Grab), the grab is released and
        that event is completely reprocessed.  This time, however, the request
        ignores any passive grabs at or above (towards the root) the
        grab-window of the grab just released.
        The request has no effect if the specified device is not grabbed by
        the client or if it is not frozen as the result of an event.
     AsyncPairedDevice
        If the paired master device is frozen by the client, event processing
        for it continues as usual. If the paired device is frozen multiple
        times by the client on behalf of multiple separate grabs,
        AsyncPairedDevice thaws for all.
        AsyncPairedDevice has no effect if the device is not frozen by the
        client, but those devices need not be grabbed by the client.
        AsyncPairedDevice has no effect if deviceid specifies a slave device.
     SyncPairedDevice
        If the paired master device is frozen by the client, event processing (for
        the paired master device) continues normally until the next button or key
        event is reported to the client for the grabbed device (button event for
        the grabbed device, key or motion event for the device), at which time
        the device again appears to freeze. However, if the reported event causes
        the grab to be released, then the device does not freeze.
        SyncPairedDevice has no effect if the specified device is not grabbed
        by the client or if it is no frozen as the result of an event.
        SyncPairedDevice has no effect if deviceid specifies a slave device.
     SyncPair
        If both the device and the paired master device are frozen by the
        client, event processing (for both devices) continues normally until
        the next XIButtonPress, XIButtonRelease, XIKeyPress, or XIKeyRelease
        event is reported to the client for a grabbed device (button event for
        a pointer, key event for a keyboard), at which time the devices again
        appear to freeze. However, if the reported event causes the grab to be
        released, then the devices do not freeze (but if the other device is
        still grabbed, then a subsequent event for it will still cause both
        devices to freeze).
        SyncPair has no effect unless both the device and the paired master
        device are frozen by the client. If the device or paired master device
        is frozen twice by the client on behalf of two separate grabs,
        SyncPair thaws for both (but a subsequent freeze for SyncPair will
        only freeze each device once).
        SyncPair has no effect if deviceid specifies a slave device.
     AsyncPair
        If the device and the paired master device are frozen by the client,
        event processing for both devices continues normally. If a device is
        frozen twice by the client on behalf of two separate grabs, AsyncBoth
        thaws for both. AsyncPair has no effect unless both the device and the
        paired master device frozen by the client.
        AsyncPair has no effect if deviceid specifies a slave device.

    ┌───
        XIPassiveGrabDevice
            deviceid:        DEVICE
            detail:          CARD32
            grab_type:       GRABTYPE
            grab_window:     Window
            cursor:          Cursor
            owner_events:    Bool
            grab_mode:       { Synchronous, Asynchronous }
            paired_device_mode: { Synchronous, Asynchronous }
            num_modifiers:   INT16
            mask_len:        CARD16
            masks:           SETofEVENTMASK
            modifiers:       CARD32 or GrabAnyModifier
            ▶
            num_modifiers_return:    INT16
            modifiers_return:        GRABMODIFIERINFO
    └───

        GRABTYPE         { GrabtypeButton, GrabtypeKeycode, GrabtypeEnter,
                           GrabtypeFocusIn, GrabtypeTouchBegin,
                           GrabtypeTouchObserve }

        GRABMODIFIERINFO {   status:    Access
                             modifiers: CARD32 }

Establish an explicit passive grab for a button or keycode
on the specified input device.

        cursor
            The cursor to display for the duration of the grab. If grab_type
            is not GrabtypeButton, this argument is ignored.
        deviceid
            The device to establish the passive grab on or AllDevices or
            AllMasterDevices.
        detail
            The button number, or key symbol to grab for.
            Must be 0 for GrabtypeEnter, GrabtypeFocusIn, and
            GrabtypeTouchBegin.
        grab_type
            The type of grab to establish.
        grab_window
            Events are reported relative to the grab window.
        grab_mode
            If grab-mode is Asynchronous, device event processing continues
            normally.  If the device is currently frozen by this client, then
            processing of device events is resumed. If grab-mode is
            Synchronous, the state of the grabbed device (as seen by means of
            the protocol) appears to freeze, and no further device events are
            generated by the server until the grabbing client issues a
            releasing XIAllowEvents request or until the device grab is
            released. Actual device input events are not lost while the device
            is frozen; they are simply queued for later processing.
            Must be Asynchronous for GrabtypeTouchBegin and
            GrabtypeTouchObserve (see section 4.4).
        mask_len
            Length of mask in 4 byte units.
        mask
            Event mask. An event mask for an event type T is defined as (1 << T).
        modifiers
            XKB modifier state to activate this passive grab.
        num_modifiers
            Number of elements in modifiers.
        owner_events
            Specifies whether event will be reported normally or relative to the
            grab window.
        num_modifiers_return
            Number of elements in modifiers_return
        modifiers_return
            XKB modifier state that could not be grabbed.

If owner-events is False, input events generated from this device are
reported with respect to grab-window, and are only reported if
selected by being included in the event-list.  If owner-events is
True, then if a generated event would normally be reported to this
client, it is reported normally, otherwise the event is reported
with respect to the grab-window, and is only reported if selected
by being included in the event-list. For either value of
owner-events, unreported events are discarded.

If deviceid specifies a master pointer, the modifiers of the paired
master keyboard are used. If deviceid specifies a slave pointer
the modifiers of the master keyboard paired with the attached master
pointers are used. If deviceid specifies a slave keyboard, the
modifiers of the attached master keyboard are used. Note that
activating a grab on a slave device detaches the device from its
master. In this case, the modifiers after activation of the grab are
from the slave device only and may be different to the modifier state
when the grab was triggered.

In the future, if grab_type is GrabtypeButton or GrabtypeKeyboard, the
device is actively grabbed if:

        - the device is not grabbed, and
        - the specified modifier keys are down, and
        - the grab_type is GrabtypeButton and the button specified in detail
          is logically pressed or the grab_type is GrabtypeKeycode and the
          keycode specified in detail is logically pressed, and
        - the grab_window contains the pointer, and
        - a passive grab on the same button/keycode + modifier
          combination does not exist on an ancestor of grab_window.

Otherwise, if grab_type is GrabtypeEnter or GrabtypeFocusIn, the
device is actively grabbed if:

        - the device is not actively grabbed, and
        - the specified modifier keys are down, and
        - the grab_type is GrabtypeEnter and the device's pointer has moved
          into grab_window or a descendant of grab_window, or the grab_type is
          GrabtypeFocusIn and the device's focus has been set to the
          grab_window or a descendant of grab_window,
        - a passive grab of the same grab_type + modifier combination does not
          does not exist on an ancestor of grab_window.

Or if grab_type is GrabtypeTouchBegin or GrabtypeTouchObserve, a
touch grab (see section 4.4) begins if:

- a touch begins in grab_window or one of its ancestors, and
- the specified modifier keys are down

Ownership of the touch sequence is granted to the grabbing client if:

- grab_type is not GrabtypeTouchObserve, and
- a TouchBegin or pointer grab for an emulated touch sequence of a
  direct touch device with the same modifier set does not exist on an
  ancestor of grab_window, or all applicable grabs have released ownership.

A modifier of GrabAnyModifier is equivalent to issuing the request for
all possible modifier combinations (including no modifiers). A client
may request a grab for GrabAnyModifier and explicit modifier
combinations in the same request.

A GrabtypeButton or GrabtypeKeyboard grab is released when all buttons
or keycode are released, independent of the state of modifier keys.
A GrabtypeEnter or GrabtypeFocusIn grab is released when the
pointer or focus leaves the window and all of its descendants,
independent of the state of modifier keys.
A GrabtypeTouchBegin grab is released when the touch sequence ends or
the client uses XIAllowTouchEvents with mode TouchReject.
A GrabtypeTouchBegin grab is converted to a GrabtypeTouchObserve grab
when the client uses XIAllowTouchEvents with mode TouchObserve.
A GrabtypeTouchObserve grab is released when the touch sequence ends.
Note that the logical state of a device (as seen by means of the
protocol) may lag the physical state if device event processing is
frozen.

This request overrides all previous passive grabs by the same
client on the same button/key/enter/focus in + modifier combinations
on the same window.

If some other client already has issued a XIPassiveGrabDevice request
with the same button or keycode and modifier combination, the
failed modifier combinations is returned in modifiers_return. If some
other client already has issued an XIPassiveGrabDevice request of
grab_type XIGrabtypeEnter, XIGrabtypeFocusIn, XIGrabtypeTouchBegin, or
XIGrabtypeTouchBeginInert with the same grab_window and the same
modifier combination, the failed modifier combinations are returned
in modifiers_return. If num_modifiers_return is zero, all passive
grabs have been successful.

If a button grab or enter grab activates, EnterNotify and LeaveNotify
events with mode Grab are generated as if the pointer were to suddenly
warp from its current position some position in the grab_window.
However, the pointer does not warp, and the pointer position is used
as both the initial and final positions for the events.

If a keycode grab or focus grab activates, FocusIn and FocusOut events
with mode Grab are generated as if the focus were to change from the
current window to the grab_window.

If an enter or focus in grab activates, additional EnterNotify events
with mode XIPassiveGrabNotify are generated as if the pointer or focus
were to suddenly warp from its current position to some position in
the grab window.  These events are sent to the grabbing client only
and only if the grab event mask has selected for it. If such a passive
grab deactivates, addional LeaveNotify events with mode
XIPassiveUngrabNotify are generated and sent to the grabbing client
before the grab deactivates.

See section 4.4 for additional notes on touch grabs, as they do not
behave like traditional grabs: in particular, they do not freeze the
device, and delivery of touch events continues even if the device is
frozen due to a grab by another client.

    ┌───
        XIPassiveUngrabDevice
            deviceid:        DEVICEID
            detail:          CARD32
            grab_type:       GRABTYPE
            grab_window:     Window
            num_modifiers:   INT16
            modifiers:       MODIFIERINFO
    └───

Release an explicit passive grab on the specified input device.

        deviceid
            The device to establish the passive grab on.
        detail
            The button number or key symbol to ungrab.
            Must be 0 for GrabtypeEnter, GrabtypeFocusIn, and
            GrabtypeTouchBegin.
        grab_type
            The type of grab to establish.
        grab_window
            Events are reported relative to the grab window.
        modifiers
            XKB modifier state to activate this passive grab.
        num_modifiers
            Number of elements in modifiers.

This request has no effect if the client does not have a passive grab
of the same type, same button or keycode (if applicable) and modifier
combination on the grab_window.

    ┌───
        XIListProperties
            deviceid:        DEVICEID
            ▶
            num_properties:  INT16
            properties:      LISTofATOM
    └───

List the properties associated with the given device.

        deviceid
            The device to list the properties for.
        num_atoms
            Number of atoms in the reply
        atoms
            All properties on the device.

    ┌───
        XIChangeProperty
            deviceid:        DEVICEID
            property:        ATOM
            type:            ATOM
            format:          { 8, 16, 32 }
            mode:            { Append, Prepend, Replace }
            num_items:       CARD32
            data:            LISTofINT8, or LISTofINT16, or LISTofINT32
    └───

Change the given property on the given device.

        deviceid
            The device to change the property on.
        property
            The property to modify.
        type
            The property's type.
        mode
            One of Append, Prepend, or Replace
        num_items
            Number of items following this request.
        data
            Property data (nitems * format/8 bytes)

The type is uninterpreted by the server. The format specifies whether
the data should be viewed as a list of 8-bit, 16-bit, or 32-bit
quantities so that the server can correctly byte-swap as necessary.

If the mode is Replace, the previous propert y value is discarded.  If
the mode is Prepend or Append, then the type and format must match the
existing property value (or a Match error results). If the property is
undefined, it is treated as defined with the correct type and format
with zero-length data. For Prepend, the data is tacked on to the
beginning of the existing data, and for Append, it is tacked on to the
end of the existing data.

The lifetime of a property is not tied to the storing client. Properties
remain until explicitly deleted, until the device is removed, or
until server reset.

A property cannot be deleted by setting nitems to zero. To delete a
property, use XIDeleteProperty.

This request generates an XIPropertyEvent.

    ┌───
        XIDeleteProperty
            deviceid:        DEVICEID
            property:        ATOM
    └───

Deletes the given property on the given device.

        deviceid
            The device to delete the property on.
        property
            The property to delete.

If the property is deleted, an XIPropertyEvent is generated on the device.
If the property does not exist, this request does nothing.

    ┌───
        XIGetProperty
            deviceid:        DEVICEID
            property:        ATOM
            type:            Atom or AnyPropertyType
            offset:          CARD32
            len:             CARD32
            delete:          BOOL
            ▶
            type:            Atom
            bytes_after:     CARD32
            num_items:       CARD32
            format:          { 8, 16, 32 }
            data:            LISTofINT8, or LISTofINT16, or LISTofINT32
    └───

Get the data for the given property on the given device.

        deviceid
            The device to retrieve the property data from.
        property
            The property to retrieve the data from..
        type
            The property type to retrieve or AnyPropertyType
        offset
            The offset in 4-byte units.
        len
            Number of bytes to receive in 4-byte units.
        delete
            Delete the property after retrieving the data.
        bytes_after
            Number of unread bytes in the stored property
        num_items
            Number of items in data
        format
            8, 16, or 32
        data
            Property data (nitems * format/8 bytes)

If the specified property does not exist for the specified device, then
the return type is None, the format and bytes-after are zero, and the value is
empty. The delete argument is ignored in this case. If the specified property
exists but its type does not match the specified type, then the return
type is the actual type of the property, the format is the actual format of the
property (never zero), the bytes-after is the length of the property in bytes
(even if the format is 16 or 32), and the value is empty. The delete
argument is ignored in this case. If the specified property exists and
either AnyPropertyType is specified or the specified type matches the actual
type of the property, then the return type is the actual type of the property,
the format is the actual format of the property
(never zero), and the bytes-after and value are as follows, given:
         N = actual length of the stored property in bytes
            (even if the format is 16 or 32)
         I = 4 * long-offset
         T = N−I
         L = MINIMUM(T, 4 * long-length)
         A = N − (I + L)
The returned value starts at byte index I in the property (indexing
from 0), and its length in bytes is L. However, it is a Value error if
offset is given such that L is negative. The value of bytes_after is A,
giving the number of trailing unread bytes in the stored property. If
delete is True and the bytes_after is zero, the property is also
deleted from the device, and a XIPropertyNotify event is generated on
the device.  
     
    ┌───
        XIAllowTouchEvents: (since XI 2.1)
            deviceid:        DEVICEID
            touchid:         CARD32
            event_mode:      ALLOWTOUCHMODE
            flags:           SETofALLOWTOUCHFLAGS
    └───

    ALLOWTOUCHMODE  { TouchAccept, TouchReject, TouchObserve }
    ALLOWTOUCHFLAGS (none currently defined)

The XIAllowTouchEvents request allows the current owner of a touch
sequence to direct further delivery.

    deviceid
        The slave device ID for a grabbed touch sequence.
    touchid
        The ID of the touch sequence to modify.
    event_mode
        Given TouchAccept, the client is deemed to have taken control of the
        touch sequence; TouchEnd events will be sent to all other clients
        listening to the touch sequence, and they will no longer receive any
        TouchUpdate events.
        Given TouchReject, the client is no longer interested in the touch
        sequence, and will receive a TouchEnd event; ownership will be passed
        on to the next listener.
        Given TouchObserve, the client is not interested in ownership, but
        still wishes to receive TouchUpdate events; ownership will be passed on
        to the next listener.
    flags
        A bitmask of applicable flags.

A BadValue error occurs if the touch ID is invalid, or BadAccess if this
client is not the current owner of the specified touch ID.  BadValue errors
also occur if an invalid value is given for event_mode.  Any flags not
understood by the server will be ignored.


8. Events:
----------

An event specifies its length in 4-byte units after the initial 32 bytes.
Future versions of the protocol may provide additional information
in the same event, thus increasing the event size. Clients are required to
always read the number of bytes specified by the event, not the size of the
event they may have been compiled against.


The following event types are available in XI2.

Version 2.0:
        HierarchyChanged
        DeviceChanged
        KeyPress
        KeyRelease
        ButtonPress
        ButtonRelease
        Motion
        RawKeyPress
        RawKeyRelease
        RawButtonPress
        RawButtonRelease
        RawMotion
        Enter
        Leave
        FocusIn
        FocusOut
        PropertyEvent
Version 2.1:
        TouchBegin
        TouchUpdate
        TouchOwnership
        TouchEnd

All events have a set of common fields specified as EVENTHEADER.


    EVENTHEADER { type:                       BYTE
                  extension:                  BYTE
                  sequenceNumber:             CARD16
                  length:                     CARD32
                  evtype:                     CARD16
                  deviceid:                   DEVICEID
                  time:                       Time }

    type
        Always GenericEvent.
    extension
        Always the X Input extension offset.
    sequenceNumber
        Sequence number of last request processed by the server.
    length
        Length in 4-byte units after the initial 32 bytes.
    evtype
        XI-specific event type.
    deviceid
        Numerical device id for a device.
    time
        Time in ms when the event occurred.


    ┌───
        HierarchyEvent:
            EVENTHEADER
            flags:                      SETofHIERARCHYMASK
            num_info:                   CARD16
            info:                       LISTofHIERARCHYINFO
    └───


    HIERARCHYMASK { MasterAdded, MasterRemoved, SlaveAttached, SlaveDetached,
                    SlaveAdded, SlaveRemoved, DeviceEnabled, DeviceDisabled }

    HIERARCHYINFO { deviceid:           DEVICEID,
                    attachment:         DEVICEID,
                    type:               DEVICEUSE
                    enabled:            BOOL
                    flags:              SETofHIERARCHYMASK}

    flags
        Set of the changes that have occured, causing this event.
    num_info
        The number of device info structs following the request.
    info:
        The current hierarchy information.

An XIHierarchyEvent is sent whenever the device hierarchy been
changed. The flags specify all types of hierarchy modifiations that have
occured.
For all devices, info details the hierarchy information after the
modification of the hierarchy has occured. For each device specified with
deviceid:

- if type is MasterPointer or MasterKeyboard, attachment decribes the
  pairing of this device.
- if type is SlavePointer or SlaveKeyboard, attachment describes the
  master device this device is attached to.
- if type is FloatingSlave device, attachment is undefined.

    enabled
         True if the device is enabled and can send events. A disabled master
         device will not forward events from an attached, enabled slave
         device.

Note: Multiple devices may be affected in one hierarchy change,
deviceid in an XIHierarchyEvent is always the first affected
device. Clients should ignore deviceid and instead use the devices list.

    ┌───
        DeviceChangedEvent:
            EVENTHEADER
            reason:                CHANGEREASON
            source:                DEVICEID
            num_classes:           CARD16
            classes:               LISTofCLASS
    └───

    CHANGEREASON { SlaveSwitch, DeviceChange }

A DeviceChangeEvent is sent whenever a device changes it's capabilities.
This can happen either by a new slave device sending events through a
master device, or by a physical device changing capabilities at runtime.

    reason
        The reason for generating this event.
        If reason is SlaveSwitch, the slave device sending events through
        this device has changed and source specifies the new slave device.
        A SlaveSwitch reason can only occur on a master device.
        If reason is DeviceChange, the device itself has changed through
        other means (e.g. a physical device change) and source is
        the device itself.
    source
        The source of the new classes.
    num_classes
        Number of classes provided.
    classes
        Details the available classes provided by the device.  The order the
        classes are provided in is undefined.

For a detailed description of classes, see the XQueryDevice request.

    ┌───
        DeviceEvent:
            EVENTHEADER
            detail:                     CARD32
            root:                       Window
            event:                      Window
            child:                      Window
            root_x:                     FP1616
            root_y:                     FP1616
            event_x:                    FP1616
            event_y:                    FP1616
            buttons_len:                CARD16
            valuators_len:              CARD16
            sourceid:                   DEVICEID
            mods:                       MODIFIERINFO
            group:                      GROUPINFO
            flags:                      DEVICEEEVENTFLAGS
            buttons:                    SETofBUTTONMASK
            valuators:                  SETofVALUATORMASK
            axisvalues:                 LISTofFP3232
            active_touches:             CARD32
    └───

    BUTTONBIT { (1 << Button1), (1 << Button2), ... , (1 << ButtonN) }
    VALUATORBIT { (1 << 1), ( 1 << 2), ... ( 1 << n) }

    MODIFIERINFO  { base_mods:           CARD32,
                    latched_mods:        CARD32,
                    locked_mods:         CARD32,
                    effective_mods:      CARD32}
    GROUPINFO     { base_group:          CARD8,
                    latched_group:       CARD8,
                    locked_group:        CARD8,
                    effective_group:     CARD8}

    DEVICEEVENTFLAGS (all events): none
    DEVICEEVENTFLAGS (key events only): { KeyRepeat }
    DEVICEEVENTFLAGS (pointer and touch events only): { PointerEmulated }
    DEVICEEVENTFLAGS (touch events only): { TouchPendingEnd }

An XIDeviceEvent is generated whenever the logical state of a device
changes in response to a button press, a button release, a motion, a key
press or a key release. The event type may be one of KeyPress,
KeyRelease, ButtonPress, ButtonRelease, Motion.

    XI 2.1: The event type may also be TouchBegin, TouchUpdate, or TouchEnd.

    detail
        The button number, key code, touch ID, or 0.
    root
    event
    child
        The root window, event window or subwindow, respectively. See core
        protocol specification for more detail.
    root_x
    root_y
        The position of the pointer in screen coordinates (16.16 fixed point).
    event_x
    event_y
        The position of the pointer in screen coordinates relative to the
        event window (16.16 fixed point).

    buttons_len
        The length of buttons in 4 byte units.
    valuators_len
        The length of valuators in 4 byte units.
    sourceid
        The source device that originally generated the event.
    mods
        XKB modifier state before the event occured.
    group
        XKB group state before the event.
    buttons
        Button state before the event.
    valuators
        Bitmask of valuators provided in axisvalues.
        XI 2.1: For event types TouchBegin, TouchUpdate, and TouchEnd, the
        valuators are those specified as TouchAxisClass.
    axisvalues
        Valuator data in device-native resolution.
        XI 2.1: For event types TouchBegin, TouchUpdate, and TouchEnd, the
        valuators are those specified as TouchAxisClass.
    flags
        Miscellaneous information about this event; the union of the
        common flag set and either the key or pointer flag set,
        depending on the event type.
        KeyRepeat means that this event is for repeating purposes, and
        the physical state of the key has not changed.  This is only
        valid for KeyPress events.
        PointerEmulated means that this event is an emulated pointer event
        caused by a touch device. A client listening to touch events and pointer
        events should ignore PointerEmulated events to avoid duplicate
        processing.  This is only valid for pointer events (MotionNotify,
        ButtonPress, ButtonRelease).
        TouchAccepted (for TouchEnd events only) means that the current owner
        of the touch stream has “accepted” it, and this client will not receive
        any further events from that touch sequence.
        TouchPendingEnd (for touch events only) means that the touch
        has physically ended, however another client still holds a grab, so the
        touch should be considered alive until all grabbing clients have
        accepted or passed on ownership.  The touch will not generate any
        further motion events once an event with TouchPendingEnd has been
        received.
    active_touches
        Only in XI 2.1 and later. Only valid for TouchBegin, TouchUpdate, and
        TouchEnd events.

The active_touches value denotes the number of touches in contact with
the source touch device surface when the event occurred. The value
includes the new touch for a TouchBegin event, and does not include the
ending touch for a TouchEnd event.

Modifier state in mods is detailed as follows:

    base_mods
        XKB base modifier state.
    latched_mods
        XKB latched modifier state.
    locked_mods
        XKB locked modifier state.

    Group state in group is detailed as follows:
    base_group
        XKB base group state.
    latched_group
        XKB latched group state.
    locked_group
        XKB locked group state.

    XI 2.1:

A TouchBegin event is generated whenever a new touch sequence initializes
A TouchEnd event is generated whenever a touch sequence ceases. A
TouchUpdate event is generated whenever a touch axis valuator value
changes, or a flag (e.g. pending end) has changed for that touch sequence;
this may result in a TouchUpdate event being sent with zero valuators. A
TouchOwnership event is sent when a client becomes the owner of a touch.

The average finger size is significantly larger than one pixel. The
selection of the hotspot of a touchpoint is implementation dependent and
may not be the logical center of the touch.

Touch tracking IDs are provided in the detail field of touch events. Its
value is always provided in every touch event. Tracking IDs are
represented as unsigned 32-bit values and increase in value for each new
touch, wrapping back to 0 upon reaching the numerical limit of IDs. IDs are
unique per each slave touch device.

Touch events do not generate enter/leave events.

    ┌───
        RawEvent
            EVENTHEADER
            detail:                    CARD32
            flags:                     DEVICEEVENTFLAGS
            valuators_len:             CARD16
            valuators:                 SETofVALUATORMASK
            axisvalues:                LISTofFP3232
            axisvalues_raw:            LISTofFP3232
    └───

A RawEvent provides the information provided by the driver to the
client. RawEvent provides both the raw data as supplied by the driver and
transformed data as used in the server. Transformations include, but are
not limited to, axis clipping and acceleration.
Transformed valuator data may be equivalent to raw data. In this case,
both raw and transformed valuator data is provided.
RawEvents are sent exclusively to all root windows or to the client
that grabbed the device only.

    eventtype
        The type of event that occured on the device.
    detail
        The button number or keycode.
    flags
        Flags as described in DeviceEvent.
    valuators_len
        The length of valuators in 4 byte units.
    valuators
        Bitmask of valuators provided in axisvalues and axisvalues_raw.
    axisvalues
        Valuator data in device-native resolution.
    axisvalues_raw
        Untransformed valuator data in device-native resolution.

    ┌───
        Enter or Leave or FocusIn or FocusOut
            EVENTHEADER
            root:               Window
            event:              Window
            child:              Window
            sourceid:           DEVICEID
            root_x:             FP1616
            root_y:             FP1616
            event_x             FP1616
            event_y:            FP1616
            mode:               NOTIFYMODE
            detail:             NOTIFYDETAIL
            same_screen:        BOOL
            focus:              BOOL
            mods:               MODIFIERINFO
            group:              GROUPINFO
            buttons_len:        CARD16
            buttons:            SETofBUTTONMASK
    └───

    NOTIFYMODE { Normal, Grab, Ungrab }
    NOTIFYDETAIL { Ancestor, Virtual, Inferior, Nonlinear, NonlinearVirtual,
                   Pointer, PointerRoot, None }

Enter or Leave events are sent whenever a device's pointer enters or
leaves a window.
FocusIn or FocusOut events are sent whenever a device's focus is set to or
away from a window.
The enter/leave and focus in/out model is described in the core protocol
specification, Section 11. (EnterNotify, LeaveNotify events).

For enter and leave events, the modifier and group state is the state of
the paired master device if the device is a master device, or the state of
the attached master keyboard if the device is an attached slave device, or
zero if the device is a floating slave device.

For focus in and out events, the button state is the state of the paired
master device if the device is a master device, or the state of the
attached master keyboard if the device is an attached slave device, or
zero if the device is a floating slave device.

    root
    event
    child
        The root window, event window, and child window, respectively. See the
        core protocol specification for more detail.
    sourceid
        The device that caused the pointer to move.
    root_x
    root_y
        The pointer coordinates relative to the root window.
    event_x
    event_y
        The pointer coordinates relative to the event window.
    mode
        Normal pointer motion events have mode Normal. Pseudo-motion events
        when a grab activates have mode Grab, and pseudo-motion events when a
        grab deactivates have mode Ungrab. Pseudo-motion events caused by the
        activation or deactivation of a passive enter or focus in grab have mode
        XIPassiveGrabNotify or XIPassiveUngrabNotify.
    detail
        Specifies the relation of the event window to the window the pointer
        entered or left. See the core protocol spec for details.
    same_screen
        True if the event window is on the same screen as the pointer's root
        window.
    focus
        If the event window is the focus window or an inferior of the focus
        window, then focus is True. Otherwise, focus is False. This field is
        unspecified for focus in/out events.
    mods
        XKB modifier state before the event occured.
    group
        XKB group state before the event.
    buttons_len
        The length of buttons in 4 byte units.
    buttons
        Button state before the event.

    ┌───
        XIPropertyEvent
            EVENTHEADER
            property:           ATOM
            what:               { PropertyCreated, PropertyDeleted, PropertyModified }
    └───

XIPropertyEvents are sent whenever a device property is created, deleted or
modified by a client.

    property
        The property that has been created, deleted, or modified
    what
        Specifies what has been changed.
     
XI 2.1:

    ┌───
        TouchOwnershipEvent (since XI 2.1):
            EVENTHEADER
            sourceid:                   DEVICEID
            touchid:                    CARD32
            flags:                      SETofTOUCHOWNERSHIPFLAGS
    └───

    TOUCHOWNERSHIPFLAGS:    (none currently defined)

A TouchOwnershipEvent indicates that ownership has changed, and the client
is now the owner of the touch sequence specified by touchid.

    sourceid
        The source device that originally generated the event.
    touchid
        The identifier of the touch sequence.
    flags
        A bitmask of flags for this event.


//                            ❧❧❧❧❧❧❧❧❧❧❧

Appendix A: XI 2.1 Use-cases
----------------------------

All use-cases that include the receiving and processing of touch events
require the client to announce XI 2.1 support in the XIQueryVersion request.

- Client C wants to process touch events from a device D on window W.
    - C calls XISelectEvent for
      XI_Touch{Begin|Update|End} from D on W.
    - C receives TouchBegin whenever a touch sequence starts within
      W's borders.
    - C receives TouchUpdate events whenever a touch axis valuator value
      changes for a touch sequence it received a TouchBegin event for.
    - C receives TouchEnd whenever a touch it received a TouchBegin event
      for ceases.

- Client C wants to pre-process touch events from a device D on window W, while
  client I wants to pre-process touch events from device D on the parent window
  of W.
    - C calls XISelectEvent for
      XI_Touch{Begin|Update|Ownership|End} from D on W.
    - I calls XIPassiveGrab for
      XI_Touch{Begin|Update|Ownership|End} from D on a parent
      window of W.
    - I receives TouchBegin whenever a touch begins within window W, as well
      as a TouchOwnership event indicating that it currently owns the touch
      sequence.  C receives a TouchBegin event as well, but without
      TouchOwnership.
    - When a touch axis valuator changes in this touch sequence, both I and C
      receive a TouchUpdate event.  I may process the event to determine if it
      is going to accept or reject the touch, whereas C may perform reversible
      processing.
    - If I decides it is going to claim the touch sequence for its exclusive
      processing, it calls XIAllowTouchEvents with the XITouchAccept flag set;
      at this point, C receives a TouchEnd event, and undoes any processing it
      has already performed due to the touch sequence.  Further TouchUpdate
      events are delivered only to I.
    - Alternatively, if I decides it does not want to receive further events
      from this touch sequence, it calls XIAllowTouchEvents with the
      XITouchReject flag set; at this point, I receives a TouchEnd event
      confirming that it has rejected the touch.  C receives a TouchOwnership
      event confirming that it is now the new owner of the touch, and further
      TouchUpdate events are delivered only to C.  As C now owns the touch,
      it is free to perform irreversible processing of the sequence.
    - When the touch physically ceases, a TouchEnd event is sent to C.

- Client C wants to pre-process touch events from a direct touch device D on
  window W, while client I wants to process pointer events on window W's parent,
  window Y.
    - I calls XIPassiveGrab for XI_{ButtonPress,MotionNotify,ButtonRelease} to
      create a synchronous pointer grab from D on Y.
    - C calls XISelectEvent for
      XI_Touch{Begin|Update|Ownership|End} from D on W.
    - I receives a ButtonPress event whenever a touch begins within W, and is
      considered the owner of the event.  C receives a TouchBegin event, but
      does not receive a TouchOwnership event.
    - When the touchpoint moves, C will receive a TouchUpdate event.  Event
      delivery to I is be subject to the synchronous delivery mechanism. The
      emulated motion notify event is queued in the server while the device is
      frozen.
    - I may assert ownership by calling XIAllowEvents on Y with any mode other
      than ReplayDevice, which will cause all further events to be sent only to
      I, with a TouchEnd event being sent to C.
    - Alternatively, I may reject the touch sequence by calling XIAllowEvents on
      Y with mode ReplayDevice, which will cause no further events from that
      touch to be sent to I, and a TouchOwnership event to be sent to C, with
      subsequent motion events being sent as TouchUpdate events.

-  Driver DRV provides touch support from tracked device D:
    - DRV initializes a TouchClass for the device and a TouchAxisClass for
      each axis available on the device.
    - DRV parses D's device protocol and selects one touch sequence to be
      emulated as pointer event.
    - DRV calls the respective input driver API with the touch sequence
      data. The touch sequence emulating a pointer has the respective flag
      set. DRV does not submit pointer data for any touchpoint.

//                            ❧❧❧❧❧❧❧❧❧❧❧
